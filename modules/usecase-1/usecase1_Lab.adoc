== Use Case 1 - Camel Routes with CSV/Bindy Dataformat & DataMapper Tool to enhance the Java objects

The purpose of the use case is to develop some Apache Camel pipeline routes where we will process CSV files, read the CSV records and transform the records to Java Objects.
Next, we will split the List of the Java Objects to enhance each Java Object using the JBoss Fuse Data Mapper tool. The java object enhanced will be finally transformed into a JSON String that you will
save into a file.

The DLQ pattern must be implemented to move the "erroneous" CSV records into an error folder (using Exception Strategy and DLQErrorHandler).

.Goals
* Build an Apache Camel route to consume CSV files and transform the records into Java Objects using the Bindy Transformation component
* Split the list of the Java Objects received and apply a Java to Java transformation using the Fuse Data Mapper Tool (from org.acme.Customer to org.globex.Account)
* Map the fields as defined within the table
* Transform the Java object created (= org.globex.Account) into individual JSON file
* Implement the DLQ Pattern to move the erroneous CSV record(s) into an error folder

:numbered:

== Import the Project

. In JBoss Developer Studio, switch to the *Git* perspective. 
. Click the icon at the top to clone a Git repository and add the clone to this view.
. In the *URI* text box, copy and paste the following: 
+
------
https://github.com/gpe-mw-training/fuse-for-practitioners-labs.git
------
+
. Switch to *Project Explorer* for the *JBoss* perspective.
. Import a new Maven project by selecting *File -> Import -> Maven -> Existing Maven Projects -> Next*. Import the `core` and it's parent project
. Navigate to the location of the Git projects for the Data Transformation tool and click *Finish*.
. Click the *Project Explorer* tab and expand the `Inbound` project node. 
+  
.Application structure
image::images/application_structure.png[width="40%"]

. Examine the following files and folders that appear in the expanded view:

* `core`: Area in which you will develop the 3 parts of the use-case. 
+
Sub-folders are:
+
** `artifacts` : WSDL and XSD files you work from
** `inbound` : route or service that receives the patient payload
** `xlate` : route that marshals the Java object to XML
** `outbound` : route that publishes the XML payload on a A-MQ queue

== Develop the Inbound application

=== CXF Rest Service
. Recommendation is to us a standard REST service CXF-RS. You can use Spring or Blueprint which starts a RESTful service with an impl. Inside the impl, you can create a producer template and call a direct endpoint in Camel. Go to blueprint.xml and create a bean which is the REST service. You will implement the add, update and search methods in the REST endpoint service.

Alternately, you can use the Camel REST component. 

Use the former design to be able to formulate a proper response back to the client to indicate why the request failed. Also you can validate schema against the incoming payloads.

Implement a Java class that is the REST endpoint. The class creates a producer template and calls the direct route. The direct route puts the message on A-MQ and returns, allowing you to return an 'OK' status to the client in the Java class.


=== Marshal the Java object to XML

Using the JAXB marshaller, convert the payload to XML

=== Publish the XML on A-MQ queue

Once the message is successfully published, a 'Done' XML string is sent back to the client.

=== Develop the JUnit Tests

Develop a feature and a fabric profile. Test using SOAPUI or curl. 

=== Build the `Inbound` Project
. On the command line, run the following commands:
* mvn clean install
* mvn camel:run


